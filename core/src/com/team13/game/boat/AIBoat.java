package com.team13.game.boat;

import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.math.Rectangle;
import com.team13.game.lane.Lane;
import com.team13.game.obstacle.Obstacle;
import com.team13.game.obstacle.Spawn;
import com.team13.game.stats.Position;
import com.team13.game.stats.Stats;

//Fields

/**
 * Class to control boats not controlled by te user.
 */
public class AIBoat extends Boat{
    /**
     * Holds the detection distance for obstacles.
     * Is equal to the skillLevel of an AI
     */
    private final int detectionDistance;

    /**
     * Holds a reference to the Lane the boat is in.
     */
    private final Lane aiLane;


//Constructors

    /**
     * Constructor for the boat_ai.
     * Assigns the all the values needed to render the AIBoat.
     * Boat initial position. Stats for the boat (generated by the StatsFactory)
     * Texture (FileHandle for which is generated with TexturePicker). Sprite, to which the texture is assigned.
     * Sprite width and height, precalculated from the sprite's bounding box.
     *
     * @param position Position objet holding x and y position of the boat
     * @param stats Stats object holding all stats of the boat.
     * @param skillLevel How far ahead the AI can see an Obstacle. Higher skillLevel, the better AI performs.
     * @param aiLane The lane the AI boat is in. Used to avoid going out of lane boundaries.
     * @param textureLocation FileHandle with the location of the texture AI needs to use.
     *
     * @see Stats
     * @see Position
     * @see Lane
     * @see com.team13.game.utils.StatsFactory
     * @see com.team13.game.utils.TexturePicker
     */
    public AIBoat(Position position, Stats stats, int skillLevel, final Lane aiLane, FileHandle textureLocation){
        // Drawing things.
        spriteScale = 0.2F;
        boatPosition = position;
        boatStats = stats;
        boatTexture = new Texture(textureLocation);
        boatTexture.setFilter(Texture.TextureFilter.Nearest, Texture.TextureFilter.Nearest);
        boatSprite = new Sprite(boatTexture);
        boatSprite.setPosition(boatPosition.getPosX(), boatPosition.getPosY());
        boatSprite.setScale(spriteScale);
        spriteWidth = boatSprite.getBoundingRectangle().width;
        spriteHeight = boatSprite.getBoundingRectangle().height;

        this.aiLane = aiLane;

        detectionDistance = skillLevel;
    }

//Methods

    /**
     * Calculates which direction teh boat needs to turn in order to avoid an obstacle.
     * Will also try to stay inside of the lane as much as possible.
     * If going out of the lane is unavoidable, it will only go 1 full sprite width out of the lane.
     *
     * @param obstacle The obstacle AI is trying to avoid.
     * @return Direction AI needs to turn in to avoid the obstacle.
     * @see Obstacle
     */
    public String direction(Obstacle obstacle) {

        // Provides a way to react to different kinds of obstacles later.
        if(obstacle instanceof Obstacle){
            if (boatPosition.getPosX() + spriteWidth < aiLane.getlBorder()){
                return "R";
            }
            if (boatPosition.getPosX() + spriteWidth + spriteWidth > aiLane.getrBorder()){
                return "L";
            }
            if(obstacle.getObstaclePosition().getPosX() <= aiLane.getMiddle()){
                return "R";
            }else{
                return "L";
            }
        }else{
//            if(obstacle.getVelocityX() < 0){
//                output = "R";
//            }else{
//                output = "L";
//            }
        }
        return "";
    }


    /**
     * Checks if there is an obstacle to avoid.
     * Precalculates the boundaries of the obstacle sprite.
     * If the obstacle is already behind the boat, no further calculations are performed.
     * If the obstacle is within range (which the AI's skillLevel allows it to see),
     * the obstacle's left most boundary is compared to the AI's rightmost boundary, obstacle's right most boundary is compared to the AI's left most boundary.
     * If either intersect, the obstacle is said to be on course to collide with the boat.
     *
     * @param obstacle Obstacle which is being checked.
     * @return true is AI is going to collide with obstacle, false otherwise.
     * @see Obstacle
     */
    private boolean obstacle_detected(Obstacle obstacle){
        // Added for clarity
        Rectangle obstacleBounds = obstacle.getObstacleSprite().getBoundingRectangle();
        float obstacleBottomBound = obstacleBounds.y;
        float obstacleTopBound = obstacleBottomBound + obstacleBounds.height;
        float obstacleLeftBound = obstacleBounds.x;
        float obstacleRightBound = obstacleLeftBound + obstacleBounds.width;

        if(boatPosition.getPosY() > obstacleTopBound){
            return false;
        }
        //come back if x is a range of values
        if (obstacleBottomBound < detectionDistance + boatPosition.getPosY()) {
            return obstacleLeftBound < boatPosition.getPosX() + spriteWidth ||
                    obstacleRightBound > boatPosition.getPosX();
        } else{
            return false;
        }
    }

    /**
     * Controls the AI's movement, is called every frame.
     * The boat accelerates forwards as it's default.
     * It then goes through all spawned obstacles, checking if it's going to collide with any.
     * If it is, it will perform a turn. if not, it will try to avoid the boundaries of its Lane.
     * @param spawn Spawn object holding all currently spawned Obstacles.
     * @see Spawn
     * @see Lane
     */
    @Override
    public void control(final Spawn spawn) {
        accelerate(Direction.FORWARDS);
        boatPosition.setPosY(boatPosition.getPosY() + boatStats.getSpeed());
        boolean detected = false;
        for (Obstacle o : spawn.getObstacleList()) {
            if(obstacle_detected(o)){
                detected = true;
                turn(direction(o));
            }
        }
        if (!detected){
            if (getBoatPosition().getPosX() > aiLane.getrBorder()) {
                turn("L");
            } else if (getBoatPosition().getPosX() < aiLane.getlBorder()) {
                turn("R");
            }
        }
    }


    /**
     * Performs a turn in a given direction.
     * Uses boat's manoeuvrability to determine how quickly it can perform a turn.
     * @param dir direction in which to turn.
     */
    private void turn(String dir){
        if (dir.equals("L")) {

            boatPosition.setPosX(getBoatPosition().getPosX() - getBoatStats().getManeuverability());

        } else if (dir.equals("R")) {

            boatPosition.setPosX(getBoatPosition().getPosX() + getBoatStats().getManeuverability());

        }
    }
}
